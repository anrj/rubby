"""
Pydantic Models for Rubby the Duck

This file contains the Pydantic models that define the data structures
for the Rubby the Duck conversational AI learning companion.

Installation: pip install pydantic
"""

from pydantic import BaseModel, Field
from typing import List, Literal, Optional, Dict, Any
from datetime import datetime

# ========================================
# 1. CORE CONVERSATION MODELS
# ========================================

class ChatMessage(BaseModel):
    """
    A single message in a conversation.
    This is the fundamental unit of communication between the user and Rubby.

    """
    role: Literal["user", "assistant"] = Field(description="The role of the message sender.")
    content: str = Field(min_length=1, description="The textual content of the message.")
    timestamp: datetime = Field(default_factory=datetime.now, description="When the message was sent.")
    
    class Config:
        json_schema_extra = {
            "example": {
                "role": "user",
                "content": "I'm having trouble understanding recursion.",
                "timestamp": "2025-11-06T10:00:00Z"
            }
        }

class ConversationState(BaseModel):
    """
    The full state of a conversation session sent from the client.
    The client sends this entire object with each request, making our backend stateless.

    """
    session_id: str = Field(description="A unique identifier for the current conversation session.")
    history: List[ChatMessage] = Field(description="The full history of messages in the session.")
    
    class Config:
        json_schema_extra = {
            "example": {
                "session_id": "session_abc123",
                "history": [
                    {
                        "role": "user",
                        "content": "What is recursion?",
                        "timestamp": "2025-11-06T10:00:00Z"
                    },
                    {
                        "role": "assistant",
                        "content": "That's a great question. Before I explain, can you think of an object in the real world that contains a smaller version of itself?",
                        "timestamp": "2025-11-06T10:00:05Z"
                    }
                ]
            }
        }

# ========================================
# 2. FUNCTION CALL MODELS
# ========================================

class EscalateForInsightParams(BaseModel):
    """Parameters for the 'escalate_for_insight' function call."""
    reason: str = Field(min_length=10, max_length=150, description="A brief explanation of why escalation is needed, e.g., 'User is stuck on the concept of recursion.'")
    topic: Optional[str] = Field(default=None, description="The core topic of the conversation, e.g., 'Linked Lists'.")

class ConcludeSessionParams(BaseModel):
    """Parameters for the 'conclude_session' function call."""
    summary_title: str = Field(min_length=5, max_length=100, description="A concise title for the session, e.g., 'Understanding Recursion.'")
    final_insight: str = Field(min_length=20, max_length=200, description="The user's key takeaway or 'aha!' moment that concluded the discussion.")

# ========================================
# 3. FUNCTION RESPONSE MODELS
# ========================================

class EscalateForInsightResponse(BaseModel):
    """
    The successful return value from our 'escalate_for_insight' function.
    This contains the new, more insightful question generated by the powerful LLM.

    """
    status: Literal["success"] = "success"
    data: Dict[str, str] = Field(description="The data payload containing the new question.")
    
    class Config:
        json_schema_extra = {
            "example": {
                "status": "success",
                "data": {
                    "new_question": "Instead of thinking about code, can you describe a set of Russian nesting dolls? How does that relate to our topic?"
                }
            }
        }

class ConcludeSessionResponse(BaseModel):
    """
    The successful return value from our 'conclude_session' function.
    This confirms the session has ended and provides the compiled summary.

    """
    status: Literal["success"] = "success"
    data: Dict[str, Any] = Field(description="The data payload confirming the session end and providing a summary.")
    
    class Config:
        json_schema_extra = {
            "example": {
                "status": "success",
                "data": {
                    "session_ended": True,
                    "summary_title": "Understanding Recursion",
                    "key_insights": [
                        "The base case is the smallest doll.",
                        "Each doll calling the next is the recursive step."
                    ]
                }
            }
        }

# ========================================
# 4. ERROR RESPONSE MODEL
# ========================================

class ErrorResponse(BaseModel):
    """
    Standardized error response for our API.
    This ensures consistent error handling for both the client and for logging.
    
    """
    error_code: str = Field(description="A machine-readable error code (e.g., 'ESCALATION_FAILED').")
    error_message: str = Field(description="A human-readable error message.")
    details: Optional[Dict[str, Any]] = Field(default=None, description="Additional error details for debugging.")
    timestamp: datetime = Field(default_factory=datetime.now, description="When the error occurred.")
    
    class Config:
        json_schema_extra = {
            "example": {
                "error_code": "ESCALATION_FAILED",
                "error_message": "The advanced AI was unable to generate a better question.",
                "details": {"original_reason": "User was stuck on recursion base case"},
                "timestamp": "2025-11-06T15:30:00Z"
            }
        }

# ========================================
# USAGE EXAMPLES
# ========================================

if __name__ == "__main__":
    print("=" * 60)
    print("RUBBY THE DUCK - PYDANTIC MODELS USAGE EXAMPLES")
    print("=" * 60)
    
    # Example 1: Creating a conversation state object (what the client sends)
    print("\n1. Creating a ConversationState object:")
    conversation = ConversationState(
        session_id="session_xyz789",
        history=[
            ChatMessage(role="user", content="I don't get base cases."),
            ChatMessage(role="assistant", content="No problem. Can you think of an action that has a clear stopping point?"),
            ChatMessage(role="user", content="Like... reaching the last page of a book?")
        ]
    )
    print(conversation.model_dump_json(indent=2))
    
    # Example 2: Parsing parameters for a function call from the LLM
    print("\n2. Parsing Function Call Parameters (Escalate):")
    ai_function_call_args = {
        "reason": "User is stuck on the concept of a base case.",
        "topic": "Recursion"
    }
    escalate_params = EscalateForInsightParams(**ai_function_call_args)
    print(f"LLM wants to escalate. Reason: {escalate_params.reason}")
    
    # Example 3: Creating a successful function response (what our code sends back to the LLM)
    print("\n3. Creating a Successful Function Response:")
    escalate_result = EscalateForInsightResponse(
        data={
            "new_question": "Exactly! The last page is the 'base case' for reading. What's the 'base case' for a countdown?"
        }
    )
    print(escalate_result.model_dump_json(indent=2))

    # Example 4: Creating a standardized error response
    print("\n4. Creating a Standardized Error Response:")
    error_resp = ErrorResponse(
        error_code="OPENAI_API_ERROR",
        error_message="The connection to the AI service was interrupted.",
        details={"status_code": 503}
    )
    print(error_resp.model_dump_json(indent=2))

    # Example 5: Validation catches errors
    print("\n5. Validation Error Example:")
    try:
        bad_message = ChatMessage(
            role="guest", # Invalid role!
            content=""   # Empty content not allowed!
        )
    except Exception as e:
        print(f"❌ Validation failed (as expected):")
        print(f"   {str(e)[:100]}...")

    print("\n" + "=" * 60)
    print("✅ All examples completed successfully!")
    print("=" * 60)